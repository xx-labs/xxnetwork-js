import './detectPackage';
export * from './bundle';
export type WasmImports = Record<string, (...args: never[]) => unknown>;
export type WasmMemory = {
    buffer: ArrayBuffer;
};
export declare interface InitResult<C extends WasmBaseInstance> {
    error: string | null;
    type: 'asm' | 'wasm' | 'none';
    wasm: C | null;
}
export type InitPromise<C extends WasmBaseInstance> = Promise<InitResult<C>>;
export type InitFn<C extends WasmBaseInstance> = (wbg: WasmImports) => InitPromise<C>;
export interface BridgeBase<C extends WasmBaseInstance> extends InitResult<C> {
    init(createWasm?: InitFn<C>): Promise<C | null>;
    getObject(idx: number): unknown;
    dropObject(idx: number): void;
    takeObject(idx: number): unknown;
    addObject(obj: unknown): number;
    getInt32(): Int32Array;
    getUint8(): Uint8Array;
    getU8a(ptr: number, len: number): Uint8Array;
    getString(ptr: number, len: number): string;
    allocU8a(arg: Uint8Array): [number, number];
    allocString(arg: string): [number, number];
    resultU8a(): Uint8Array;
    resultString(): string;
}
export interface WasmBaseInstance {
    memory: WasmMemory;
    __wbindgen_exn_store(a: number): void;
    __wbindgen_free(a: number, b: number): void;
    __wbindgen_malloc(a: number): number;
    __wbindgen_realloc(a: number, b: number, c: number): number;
}

import "./detectPackage.js";
export * from "./bundle.js";

/* eslint-disable @typescript-eslint/no-non-null-assertion */

import { stringToU8a, u8aToString } from '@polkadot/util';
import { Wbg } from "./wbg.js";

/**
 * @name Bridge
 * @description
 * Creates a bridge between the JS and WASM environments.
 *
 * For any bridge it is passed an function white is then called internally at the
 * time of initialization. This affectively implements the layer between WASM and
 * the native environment, providing all the plumbing needed for the Wbg classes.
 */
export class Bridge {
  #cachegetInt32;
  #cachegetUint8;
  #createWasm;
  #heap;
  #heapNext;
  #wasm;
  #wasmError;
  #wasmPromise;
  #wbg;
  #type;
  constructor(createWasm) {
    this.#createWasm = createWasm;
    this.#cachegetInt32 = null;
    this.#cachegetUint8 = null;
    this.#heap = new Array(32).fill(undefined).concat(undefined, null, true, false);
    this.#heapNext = this.#heap.length;
    this.#type = 'none';
    this.#wasm = null;
    this.#wasmError = null;
    this.#wasmPromise = null;
    this.#wbg = {
      ...new Wbg(this)
    };
  }

  /** @description Returns the init error */
  get error() {
    return this.#wasmError;
  }

  /** @description Returns the init type */
  get type() {
    return this.#type;
  }

  /** @description Returns the created wasm interface */
  get wasm() {
    return this.#wasm;
  }

  /** @description Performs the wasm initialization */
  async init(createWasm) {
    if (!this.#wasmPromise || createWasm) {
      this.#wasmPromise = (createWasm || this.#createWasm)(this.#wbg);
    }
    const {
      error,
      type,
      wasm
    } = await this.#wasmPromise;
    this.#type = type;
    this.#wasm = wasm;
    this.#wasmError = error;
    return this.#wasm;
  }

  /**
   * @internal
   * @description Gets an object from the heap
   */
  getObject(idx) {
    return this.#heap[idx];
  }

  /**
   * @internal
   * @description Removes an object from the heap
   */
  dropObject(idx) {
    if (idx < 36) {
      return;
    }
    this.#heap[idx] = this.#heapNext;
    this.#heapNext = idx;
  }

  /**
   * @internal
   * @description Retrieves and removes an object to the heap
   */
  takeObject(idx) {
    const ret = this.getObject(idx);
    this.dropObject(idx);
    return ret;
  }

  /**
   * @internal
   * @description Adds an object to the heap
   */
  addObject(obj) {
    if (this.#heapNext === this.#heap.length) {
      this.#heap.push(this.#heap.length + 1);
    }
    const idx = this.#heapNext;
    this.#heapNext = this.#heap[idx];
    this.#heap[idx] = obj;
    return idx;
  }

  /**
   * @internal
   * @description Retrieve an Int32 in the WASM interface
   */
  getInt32() {
    if (this.#cachegetInt32 === null || this.#cachegetInt32.buffer !== this.#wasm.memory.buffer) {
      this.#cachegetInt32 = new Int32Array(this.#wasm.memory.buffer);
    }
    return this.#cachegetInt32;
  }

  /**
   * @internal
   * @description Retrieve an Uint8Array in the WASM interface
   */
  getUint8() {
    if (this.#cachegetUint8 === null || this.#cachegetUint8.buffer !== this.#wasm.memory.buffer) {
      this.#cachegetUint8 = new Uint8Array(this.#wasm.memory.buffer);
    }
    return this.#cachegetUint8;
  }

  /**
   * @internal
   * @description Retrieves an Uint8Array in the WASM interface
   */
  getU8a(ptr, len) {
    return this.getUint8().subarray(ptr / 1, ptr / 1 + len);
  }

  /**
   * @internal
   * @description Retrieves a string in the WASM interface
   */
  getString(ptr, len) {
    return u8aToString(this.getU8a(ptr, len));
  }

  /**
   * @internal
   * @description Allocates an Uint8Array in the WASM interface
   */
  allocU8a(arg) {
    const ptr = this.#wasm.__wbindgen_malloc(arg.length * 1);
    this.getUint8().set(arg, ptr / 1);
    return [ptr, arg.length];
  }

  /**
   * @internal
   * @description Allocates a string in the WASM interface
   */
  allocString(arg) {
    return this.allocU8a(stringToU8a(arg));
  }

  /**
   * @internal
   * @description Retrieves an Uint8Array from the WASM interface
   */
  resultU8a() {
    const r0 = this.getInt32()[8 / 4 + 0];
    const r1 = this.getInt32()[8 / 4 + 1];
    const ret = this.getU8a(r0, r1).slice();
    this.#wasm.__wbindgen_free(r0, r1 * 1);
    return ret;
  }

  /**
   * @internal
   * @description Retrieve a string from the WASM interface
   */
  resultString() {
    return u8aToString(this.resultU8a());
  }
}
export {};
declare const _default: never[];
export default _default;
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
require("./detectPackage");
var _bundle = require("./bundle");
Object.keys(_bundle).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _bundle[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _bundle[key];
    }
  });
});
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Bridge = void 0;
var _util = require("@polkadot/util");
var _wbg = require("./wbg");

/* eslint-disable @typescript-eslint/no-non-null-assertion */

/**
 * @name Bridge
 * @description
 * Creates a bridge between the JS and WASM environments.
 *
 * For any bridge it is passed an function white is then called internally at the
 * time of initialization. This affectively implements the layer between WASM and
 * the native environment, providing all the plumbing needed for the Wbg classes.
 */
class Bridge {
  #cachegetInt32;
  #cachegetUint8;
  #createWasm;
  #heap;
  #heapNext;
  #wasm;
  #wasmError;
  #wasmPromise;
  #wbg;
  #type;
  constructor(createWasm) {
    this.#createWasm = createWasm;
    this.#cachegetInt32 = null;
    this.#cachegetUint8 = null;
    this.#heap = new Array(32).fill(undefined).concat(undefined, null, true, false);
    this.#heapNext = this.#heap.length;
    this.#type = 'none';
    this.#wasm = null;
    this.#wasmError = null;
    this.#wasmPromise = null;
    this.#wbg = {
      ...new _wbg.Wbg(this)
    };
  }

  /** @description Returns the init error */
  get error() {
    return this.#wasmError;
  }

  /** @description Returns the init type */
  get type() {
    return this.#type;
  }

  /** @description Returns the created wasm interface */
  get wasm() {
    return this.#wasm;
  }

  /** @description Performs the wasm initialization */
  async init(createWasm) {
    if (!this.#wasmPromise || createWasm) {
      this.#wasmPromise = (createWasm || this.#createWasm)(this.#wbg);
    }
    const {
      error,
      type,
      wasm
    } = await this.#wasmPromise;
    this.#type = type;
    this.#wasm = wasm;
    this.#wasmError = error;
    return this.#wasm;
  }

  /**
   * @internal
   * @description Gets an object from the heap
   */
  getObject(idx) {
    return this.#heap[idx];
  }

  /**
   * @internal
   * @description Removes an object from the heap
   */
  dropObject(idx) {
    if (idx < 36) {
      return;
    }
    this.#heap[idx] = this.#heapNext;
    this.#heapNext = idx;
  }

  /**
   * @internal
   * @description Retrieves and removes an object to the heap
   */
  takeObject(idx) {
    const ret = this.getObject(idx);
    this.dropObject(idx);
    return ret;
  }

  /**
   * @internal
   * @description Adds an object to the heap
   */
  addObject(obj) {
    if (this.#heapNext === this.#heap.length) {
      this.#heap.push(this.#heap.length + 1);
    }
    const idx = this.#heapNext;
    this.#heapNext = this.#heap[idx];
    this.#heap[idx] = obj;
    return idx;
  }

  /**
   * @internal
   * @description Retrieve an Int32 in the WASM interface
   */
  getInt32() {
    if (this.#cachegetInt32 === null || this.#cachegetInt32.buffer !== this.#wasm.memory.buffer) {
      this.#cachegetInt32 = new Int32Array(this.#wasm.memory.buffer);
    }
    return this.#cachegetInt32;
  }

  /**
   * @internal
   * @description Retrieve an Uint8Array in the WASM interface
   */
  getUint8() {
    if (this.#cachegetUint8 === null || this.#cachegetUint8.buffer !== this.#wasm.memory.buffer) {
      this.#cachegetUint8 = new Uint8Array(this.#wasm.memory.buffer);
    }
    return this.#cachegetUint8;
  }

  /**
   * @internal
   * @description Retrieves an Uint8Array in the WASM interface
   */
  getU8a(ptr, len) {
    return this.getUint8().subarray(ptr / 1, ptr / 1 + len);
  }

  /**
   * @internal
   * @description Retrieves a string in the WASM interface
   */
  getString(ptr, len) {
    return (0, _util.u8aToString)(this.getU8a(ptr, len));
  }

  /**
   * @internal
   * @description Allocates an Uint8Array in the WASM interface
   */
  allocU8a(arg) {
    const ptr = this.#wasm.__wbindgen_malloc(arg.length * 1);
    this.getUint8().set(arg, ptr / 1);
    return [ptr, arg.length];
  }

  /**
   * @internal
   * @description Allocates a string in the WASM interface
   */
  allocString(arg) {
    return this.allocU8a((0, _util.stringToU8a)(arg));
  }

  /**
   * @internal
   * @description Retrieves an Uint8Array from the WASM interface
   */
  resultU8a() {
    const r0 = this.getInt32()[8 / 4 + 0];
    const r1 = this.getInt32()[8 / 4 + 1];
    const ret = this.getU8a(r0, r1).slice();
    this.#wasm.__wbindgen_free(r0, r1 * 1);
    return ret;
  }

  /**
   * @internal
   * @description Retrieve a string from the WASM interface
   */
  resultString() {
    return (0, _util.u8aToString)(this.resultU8a());
  }
}
exports.Bridge = Bridge;
"use strict";
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _bridge = require("./bridge");
Object.keys(_bridge).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _bridge[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _bridge[key];
    }
  });
});
var _init = require("./init");
Object.keys(_init).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _init[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _init[key];
    }
  });
});
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = [];
exports.default = _default;
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.packageInfo = void 0;


const packageInfo = {
  name: '@xxnetwork/wasm-bridge',
  path: typeof __dirname === 'string' ? __dirname : 'auto',
  type: 'cjs',
  version: '1.0.0'
};
exports.packageInfo = packageInfo;
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _util = require("@polkadot/util");
var _detectOther = _interopRequireDefault(require("./detectOther"));
var _packageInfo = require("./packageInfo");


(0, _util.detectPackage)(_packageInfo.packageInfo, null, _detectOther.default);
{
  "type": "commonjs"
}
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createWasmFn = createWasmFn;

/**
 * @name createWasmFn
 * @description
 * Create a WASM (or ASM.js) creator interface based on the supplied information.
 *
 * It will attempt to create a WASM interface first and if this fails or is not available in
 * the environment, will fallback to attempting to create an ASM.js interface.
 */
function createWasmFn(root, wasmBytes, asmFn) {
  return async wbg => {
    const result = {
      error: null,
      type: 'none',
      wasm: null
    };
    try {
      if (!wasmBytes || !wasmBytes.length) {
        throw new Error('No WebAssembly provided for initialization');
      } else if (typeof WebAssembly !== 'object' || typeof WebAssembly.instantiate !== 'function') {
        throw new Error('WebAssembly is not available in your environment');
      }
      const source = await WebAssembly.instantiate(wasmBytes, {
        wbg
      });
      result.wasm = source.instance.exports;
      result.type = 'wasm';
    } catch (error) {
      // if we have a valid supplied asm.js, return that
      if (typeof asmFn === 'function') {
        result.wasm = asmFn(wbg);
        result.type = 'asm';
      } else {
        result.error = `FATAL: Unable to initialize @xxnetwork/wasm-${root}:: ${error.message}`;
        console.error(result.error);
      }
    }
    return result;
  };
}
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Wbg = void 0;
var _xRandomvalues = require("@polkadot/x-randomvalues");

const DEFAULT_CRYPTO = {
  getRandomValues: _xRandomvalues.getRandomValues
};
const DEFAULT_SELF = {
  crypto: DEFAULT_CRYPTO
};

/**
 * @name Wbg
 * @description
 * This defines the internal interfaces that wasm-bindgen used to communicate
 * with the host layer. None of these functions are available to the user, rather
 * they are called internally from the WASM code itself.
 *
 * The interfaces here are exposed in the imports on the created WASM interfaces.
 *
 * Internally the implementation does a thin layer into the supplied bridge.
 */
class Wbg {
  #bridge;
  constructor(bridge) {
    this.#bridge = bridge;
  }

  /** @internal */
  abort = () => {
    throw new Error('abort');
  };

  /** @internal */
  __wbindgen_is_undefined = idx => {
    return this.#bridge.getObject(idx) === undefined;
  };

  /** @internal */
  __wbindgen_throw = (ptr, len) => {
    throw new Error(this.#bridge.getString(ptr, len));
  };

  /** @internal */
  __wbg_self_1b7a39e3a92c949c = () => {
    return this.#bridge.addObject(DEFAULT_SELF);
  };

  /** @internal */
  __wbg_require_604837428532a733 = (ptr, len) => {
    throw new Error(`Unable to require ${this.#bridge.getString(ptr, len)}`);
  };

  /** @internal */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  __wbg_crypto_968f1772287e2df0 = _idx => {
    return this.#bridge.addObject(DEFAULT_CRYPTO);
  };

  /** @internal */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  __wbg_getRandomValues_a3d34b4fee3c2869 = _idx => {
    return this.#bridge.addObject(DEFAULT_CRYPTO.getRandomValues);
  };

  /** @internal */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  __wbg_getRandomValues_f5e14ab7ac8e995d = (_arg0, ptr, len) => {
    DEFAULT_CRYPTO.getRandomValues(this.#bridge.getU8a(ptr, len));
  };

  /** @internal */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  __wbg_randomFillSync_d5bd2d655fdf256a = (_idx, _ptr, _len) => {
    throw new Error('randomFillsync is not available');

    // getObject(idx).randomFillSync(getU8a(ptr, len));
  };

  /** @internal */
  __wbindgen_object_drop_ref = idx => {
    this.#bridge.takeObject(idx);
  };
}
exports.Wbg = Wbg;
export * from './bridge';
export * from './init';
export declare const packageInfo: {
    name: string;
    path: string;
    type: string;
    version: string;
};

export * from "./bridge.js";
export * from "./init.js";

export default [];
import type { BridgeBase, InitFn, WasmBaseInstance } from './types';
/**
 * @name Bridge
 * @description
 * Creates a bridge between the JS and WASM environments.
 *
 * For any bridge it is passed an function white is then called internally at the
 * time of initialization. This affectively implements the layer between WASM and
 * the native environment, providing all the plumbing needed for the Wbg classes.
 */
export declare class Bridge<C extends WasmBaseInstance> implements BridgeBase<C> {
    #private;
    constructor(createWasm: InitFn<C>);
    /** @description Returns the init error */
    get error(): string | null;
    /** @description Returns the init type */
    get type(): 'asm' | 'wasm' | 'none';
    /** @description Returns the created wasm interface */
    get wasm(): C | null;
    /** @description Performs the wasm initialization */
    init(createWasm?: InitFn<C>): Promise<C | null>;
    /**
     * @internal
     * @description Gets an object from the heap
     */
    getObject(idx: number): unknown;
    /**
     * @internal
     * @description Removes an object from the heap
     */
    dropObject(idx: number): void;
    /**
     * @internal
     * @description Retrieves and removes an object to the heap
     */
    takeObject(idx: number): unknown;
    /**
     * @internal
     * @description Adds an object to the heap
     */
    addObject(obj: unknown): number;
    /**
     * @internal
     * @description Retrieve an Int32 in the WASM interface
     */
    getInt32(): Int32Array;
    /**
     * @internal
     * @description Retrieve an Uint8Array in the WASM interface
     */
    getUint8(): Uint8Array;
    /**
     * @internal
     * @description Retrieves an Uint8Array in the WASM interface
     */
    getU8a(ptr: number, len: number): Uint8Array;
    /**
     * @internal
     * @description Retrieves a string in the WASM interface
     */
    getString(ptr: number, len: number): string;
    /**
     * @internal
     * @description Allocates an Uint8Array in the WASM interface
     */
    allocU8a(arg: Uint8Array): [number, number];
    /**
     * @internal
     * @description Allocates a string in the WASM interface
     */
    allocString(arg: string): [number, number];
    /**
     * @internal
     * @description Retrieves an Uint8Array from the WASM interface
     */
    resultU8a(): Uint8Array;
    /**
     * @internal
     * @description Retrieve a string from the WASM interface
     */
    resultString(): string;
}


export const packageInfo = {
  name: '@xxnetwork/wasm-bridge',
  path: (import.meta && import.meta.url) ? new URL(import.meta.url).pathname.substring(0, new URL(import.meta.url).pathname.lastIndexOf('/') + 1) : 'auto',
  type: 'esm',
  version: '1.0.0'
};


import { detectPackage } from '@polkadot/util';
import others from "./detectOther.js";
import { packageInfo } from "./packageInfo.js";
detectPackage(packageInfo, null, others);
{
  "author": "Bernardo Cardoso <bernardo@xx.network>",
  "bugs": "https://github.com/xx-labs/xxnetwork-js/issues",
  "contributors": [],
  "description": "A bridge layer between JS and Wasm",
  "engines": {
    "node": ">=14.0.0"
  },
  "homepage": "https://github.com/xx-labs/xxnetwork-js/tree/master/packages/wasm-bridge#readme",
  "license": "Apache-2.0",
  "maintainers": [],
  "name": "@xxnetwork/wasm-bridge",
  "repository": {
    "directory": "packages/wasm-bridge",
    "type": "git",
    "url": "https://github.com/xx-labs/xxnetwork-js.git"
  },
  "sideEffects": [
    "./detectPackage.js",
    "./cjs/detectPackage.js"
  ],
  "type": "module",
  "version": "1.0.0",
  "main": "./cjs/index.js",
  "module": "./index.js",
  "types": "./index.d.ts",
  "exports": {
    "./cjs/package.json": "./cjs/package.json",
    "./cjs/*": "./cjs/*.js",
    ".": {
      "types": "./index.d.ts",
      "require": "./cjs/index.js",
      "default": "./index.js"
    },
    "./bridge": {
      "types": "./bridge.d.ts",
      "require": "./cjs/bridge.js",
      "default": "./bridge.js"
    },
    "./bundle": {
      "types": "./bundle.d.ts",
      "require": "./cjs/bundle.js",
      "default": "./bundle.js"
    },
    "./detectOther": {
      "types": "./detectOther.d.ts",
      "require": "./cjs/detectOther.js",
      "default": "./detectOther.js"
    },
    "./detectPackage": {
      "types": "./detectPackage.d.ts",
      "require": "./cjs/detectPackage.js",
      "default": "./detectPackage.js"
    },
    "./init": {
      "types": "./init.d.ts",
      "require": "./cjs/init.js",
      "default": "./init.js"
    },
    "./package.json": {
      "require": "./cjs/package.json",
      "default": "./package.json"
    },
    "./packageInfo.js": {
      "types": "./packageInfo.d.ts",
      "require": "./cjs/packageInfo.js",
      "default": "./packageInfo.js"
    },
    "./packageInfo": {
      "types": "./packageInfo.d.ts",
      "require": "./cjs/packageInfo.js",
      "default": "./packageInfo.js"
    },
    "./types": {
      "types": "./types.d.ts",
      "require": "./cjs/types.js",
      "default": "./types.js"
    },
    "./wbg": {
      "types": "./wbg.d.ts",
      "require": "./cjs/wbg.js",
      "default": "./wbg.js"
    }
  },
  "dependencies": {
    "@babel/runtime": "^7.21.0"
  },
  "peerDependencies": {
    "@polkadot/util": "*",
    "@polkadot/x-randomvalues": "*"
  }
}
import type { InitFn, WasmBaseInstance, WasmImports } from './types';
/**
 * @name createWasmFn
 * @description
 * Create a WASM (or ASM.js) creator interface based on the supplied information.
 *
 * It will attempt to create a WASM interface first and if this fails or is not available in
 * the environment, will fallback to attempting to create an ASM.js interface.
 */
export declare function createWasmFn<C extends WasmBaseInstance>(root: string, wasmBytes: null | Uint8Array, asmFn: null | ((wbg: WasmImports) => C)): InitFn<C>;
export {};
import type { BridgeBase, WasmBaseInstance } from './types';
/**
 * @name Wbg
 * @description
 * This defines the internal interfaces that wasm-bindgen used to communicate
 * with the host layer. None of these functions are available to the user, rather
 * they are called internally from the WASM code itself.
 *
 * The interfaces here are exposed in the imports on the created WASM interfaces.
 *
 * Internally the implementation does a thin layer into the supplied bridge.
 */
export declare class Wbg<C extends WasmBaseInstance> {
    #private;
    constructor(bridge: BridgeBase<C>);
    /** @internal */
    abort: () => never;
    /** @internal */
    __wbindgen_is_undefined: (idx: number) => boolean;
    /** @internal */
    __wbindgen_throw: (ptr: number, len: number) => boolean;
    /** @internal */
    __wbg_self_1b7a39e3a92c949c: () => number;
    /** @internal */
    __wbg_require_604837428532a733: (ptr: number, len: number) => never;
    /** @internal */
    __wbg_crypto_968f1772287e2df0: (_idx: number) => number;
    /** @internal */
    __wbg_getRandomValues_a3d34b4fee3c2869: (_idx: number) => number;
    /** @internal */
    __wbg_getRandomValues_f5e14ab7ac8e995d: (_arg0: number, ptr: number, len: number) => void;
    /** @internal */
    __wbg_randomFillSync_d5bd2d655fdf256a: (_idx: number, _ptr: number, _len: number) => never;
    /** @internal */
    __wbindgen_object_drop_ref: (idx: number) => void;
}

/**
 * @name createWasmFn
 * @description
 * Create a WASM (or ASM.js) creator interface based on the supplied information.
 *
 * It will attempt to create a WASM interface first and if this fails or is not available in
 * the environment, will fallback to attempting to create an ASM.js interface.
 */
export function createWasmFn(root, wasmBytes, asmFn) {
  return async wbg => {
    const result = {
      error: null,
      type: 'none',
      wasm: null
    };
    try {
      if (!wasmBytes || !wasmBytes.length) {
        throw new Error('No WebAssembly provided for initialization');
      } else if (typeof WebAssembly !== 'object' || typeof WebAssembly.instantiate !== 'function') {
        throw new Error('WebAssembly is not available in your environment');
      }
      const source = await WebAssembly.instantiate(wasmBytes, {
        wbg
      });
      result.wasm = source.instance.exports;
      result.type = 'wasm';
    } catch (error) {
      // if we have a valid supplied asm.js, return that
      if (typeof asmFn === 'function') {
        result.wasm = asmFn(wbg);
        result.type = 'asm';
      } else {
        result.error = `FATAL: Unable to initialize @xxnetwork/wasm-${root}:: ${error.message}`;
        console.error(result.error);
      }
    }
    return result;
  };
}

import { getRandomValues } from '@polkadot/x-randomvalues';
const DEFAULT_CRYPTO = {
  getRandomValues
};
const DEFAULT_SELF = {
  crypto: DEFAULT_CRYPTO
};

/**
 * @name Wbg
 * @description
 * This defines the internal interfaces that wasm-bindgen used to communicate
 * with the host layer. None of these functions are available to the user, rather
 * they are called internally from the WASM code itself.
 *
 * The interfaces here are exposed in the imports on the created WASM interfaces.
 *
 * Internally the implementation does a thin layer into the supplied bridge.
 */
export class Wbg {
  #bridge;
  constructor(bridge) {
    this.#bridge = bridge;
  }

  /** @internal */
  abort = () => {
    throw new Error('abort');
  };

  /** @internal */
  __wbindgen_is_undefined = idx => {
    return this.#bridge.getObject(idx) === undefined;
  };

  /** @internal */
  __wbindgen_throw = (ptr, len) => {
    throw new Error(this.#bridge.getString(ptr, len));
  };

  /** @internal */
  __wbg_self_1b7a39e3a92c949c = () => {
    return this.#bridge.addObject(DEFAULT_SELF);
  };

  /** @internal */
  __wbg_require_604837428532a733 = (ptr, len) => {
    throw new Error(`Unable to require ${this.#bridge.getString(ptr, len)}`);
  };

  /** @internal */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  __wbg_crypto_968f1772287e2df0 = _idx => {
    return this.#bridge.addObject(DEFAULT_CRYPTO);
  };

  /** @internal */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  __wbg_getRandomValues_a3d34b4fee3c2869 = _idx => {
    return this.#bridge.addObject(DEFAULT_CRYPTO.getRandomValues);
  };

  /** @internal */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  __wbg_getRandomValues_f5e14ab7ac8e995d = (_arg0, ptr, len) => {
    DEFAULT_CRYPTO.getRandomValues(this.#bridge.getU8a(ptr, len));
  };

  /** @internal */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  __wbg_randomFillSync_d5bd2d655fdf256a = (_idx, _ptr, _len) => {
    throw new Error('randomFillsync is not available');

    // getObject(idx).randomFillSync(getU8a(ptr, len));
  };

  /** @internal */
  __wbindgen_object_drop_ref = idx => {
    this.#bridge.takeObject(idx);
  };
}